<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Project 2: Mesh Editor</h1>
<h2 align="middle">Michael Lu, CS184-aaz</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

<p>de Casteljau's algorithm is a recursive algorithm that uses linear interpolation to generate a smooth curve between two points by using a sequence of control points. I computed the locations of the intermediate points of the algorithm in each step using the relative t parameter until one point is left, which becomes the point on the Bezier curve. The entire Bezier curve is generated by running de Casteljau's on all t from 0 to 1.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="beziercurve0.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 0 of de Casteljau's</figcaption>
      </td>
      <td>
        <img src="beziercurve1.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 1 of de Casteljau's</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="beziercurve2.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 2 of de Casteljau's</figcaption>
      </td>
      <td>
        <img src="beziercurve3.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 3 of de Casteljau's</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="beziercurve4.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 4 of de Casteljau's</figcaption>
      </td>
      <td>
        <img src="beziercurve5.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 5 of de Casteljau's</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="beziercurve6.png" align="middle" width="400px"/>
        <figcaption align="middle">Different Bezier curve with different t parameter</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>

<p>For Bezier surfaces we can apply de Casteljau's along one axis of the control points to obtain a set of Bezier curves. Then interpolating between the curves along the second axis using de Casteljau's obtains the Bezier surface. I implemented this by computing the Bezier curve points along the u axis corresponding to the parameter u. Then using those points as the new control points, I computed the Bezier surface point with the parameter v.</p>

<img src="bezierteapot.png" align="middle" width="400px"/>
<figcaption align="middle">Bezier Surface: teapot</figcaption>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 3: Average normals for half-edge meshes</h3>

<p>First, I obtain the other two vertices of the face using twin() and next(). Then I compute the normal vector by taking the cross product and add it to a collective sum. Repeat for the other faces, using a do-while loop because I couldn't get the conditioning right using a for or while loop with this implementation.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="teapotunsmooth.png" align="middle" width="400px"/>
        <figcaption align="middle">Teapot with face normals shading</figcaption>
      </td>
      <td>
        <img src="teapotsmooth.png" align="middle" width="400px"/>
        <figcaption align="middle">Teapot with average vertex normals shading</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 4: Half-edge flip</h3>

<p>I essentially stored all the pointers into variables and remapped all the references in the halfedges using setNeighbors. I also set the halfedges for the faces and the vertices just to make sure everything is correct. The edges stay the same so I am confident enough to not reassign them.</p>

<p>My eventful debugging journey started with 11 minutes and 40 seconds of hand drawn diagrams and mappings on a sheet of paper. And then it ended because everything worked out xD.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="preflip.png" align="middle" width="400px"/>
        <figcaption align="middle">Modified Cube: pre edge flips</figcaption>
      </td>
      <td>
        <img src="postflip.png" align="middle" width="400px"/>
        <figcaption align="middle">Modified Cube: post edge flips</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 5: Half-edge split</h3>

<p>I did the same thing as the last part: stored all the pointers and carefuly remapped all the halfedge references using setNeighbors. Then I made sure to also set all the halfedge properties to the appropriate halfedge in the new diagram.</p>

<p>This epic debugging journey started with 17 minutes and 22 seconds of hand drawn diagrams and mappings on a sheet of paper. And then it ended because everything also worked out.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="presplit.png" align="middle" width="400px"/>
        <figcaption align="middle">Modified Cube: pre edge splits</figcaption>
      </td>
      <td>
        <img src="postsplit.png" align="middle" width="400px"/>
        <figcaption align="middle">Modified Cube: post edge splits</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="postsplitflip.png" align="middle" width="400px"/>
        <figcaption align="middle">Modified Cube: post edge splits/flips</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>

<p>I basically just did what the spec told me to do. I first compute the positions of the vertices in the input mesh, as well as the vertices associated with every edge, based on the weighting formula. Then split all the edges in the mesh and mark which halfedges are new and which are old. Then we flip all the edges that connect new vertices to old ones so that we generate the correct mesh pattern. Then finally, we copy the value of the new position of the new vertices into its position field to finalize the mesh.</p>

<p>Sharp corners and edges of meshes are smoothed out when upsampled. If we pre-split some of the nearby edges, we can preserve the general shape of the sharp edge as we upsample. The more edges we pre-split, the less the sharp corner or edge is affected or smoothed out by upsampling.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="cube0.png" align="middle" width="400px"/>
        <figcaption align="middle">Default cube mesh</figcaption>
      </td>
      <td>
        <img src="cube1.png" align="middle" width="400px"/>
        <figcaption align="middle">Cube mesh after 3 iterations of upsampling</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="cube2.png" align="middle" width="400px"/>
        <figcaption align="middle">Cube mesh with several pre-split edges</figcaption>
      </td>
      <td>
        <img src="cube3.png" align="middle" width="400px"/>
        <figcaption align="middle">Pre-split cube mesh after 3 iterations of upsampling</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>The reason that the cube does not subdivide symmetrically is that the triangles that make up the mesh are not symmetric around the cube's axes of symmetry. One way to solve this issue is to pre-split each of the edges that run along a face so that the face consists of 4 triangles. This way the mesh's triangles become symmetric along the axes of symmetry that runs through opposite faces. Another way is to flip some of the edges so that the mesh triangles are symmetric along the cube's diagonal.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="cubezero.png" align="middle" width="400px"/>
        <figcaption align="middle">Default cube mesh</figcaption>
      </td>
      <td>
        <img src="cubeup.png" align="middle" width="400px"/>
        <figcaption align="middle">Cube mesh after 4 iterations of upsampling</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="cubesplit.png" align="middle" width="400px"/>
        <figcaption align="middle">Cube mesh with split edge faces</figcaption>
      </td>
      <td>
        <img src="cubesplitup.png" align="middle" width="400px"/>
        <figcaption align="middle">Pre-split cube mesh after 4 iterations of upsampling</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="cubeflip.png" align="middle" width="400px"/>
        <figcaption align="middle">Cube mesh with flipped edges</figcaption>
      </td>
      <td>
        <img src="cubeflipup.png" align="middle" width="400px"/>
        <figcaption align="middle">Pre-flipped cube mesh after 4 iterations of upsampling</figcaption>
      </td>
    </tr>
  </table>
</div>
  
<h2 align="middle">Section III: Mesh Competition</h2>
<p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Design your own mesh!</h3>

</body>
</html>
